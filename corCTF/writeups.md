# corCTF Write-ups

## crypto/fibinary

### About the task
#### Task description
*Warmup your crypto skills with the superior number system!*
#### Task files
[enc.py](https://corctf2021-files.storage.googleapis.com/uploads/cbc718b0b14f91af5c231ed0b6091d2336484619d536bce505a34fa27ec90be8/enc.py)   
[flag.enc](https://corctf2021-files.storage.googleapis.com/uploads/034184c574279b6889c553d222d2f8c8f1725b56f70f9acb4bc716bc7cabf8df/flag.enc)
#### Task author
*quintec*
#### Task url
*https://2021.cor.team/challs*

### Write-up
#### Understanding the task
After reading the task description and quickly looking at the files we are given a few things immediately stand out:
The file flag.enc seems to be written in some sort of binary
The enc.py program uses a homemade algorithm to encrypt the contents of "flag.txt".

The algorithm seems to rely on non-destructive mathematical operators, like addition and subtraction.
The fib variable looks and sounds like a fibbonachi sequence.

The flag.enc looks like a binary file, but if you attempt to paste it into cyberchef, or any other program that decodes binary, you will quickly see that it does not contain the flag in plaintext. Therefore we have to look at the program that made the file, enc.py.

```python
fib = [1, 1]
for i in range(2, 11):
	fib.append(fib[i - 1] + fib[i - 2])

def c2f(c):
	n = ord(c)
	b = ''
	for i in range(10, -1, -1):
		if n >= fib[i]:
			n -= fib[i]
			b += '1'
		else:
			b += '0'
	return b


flag = open('flag.txt', 'r').read()
enc = ''
for c in flag:
	enc += c2f(c) + ' '
with open('flag.enc', 'w') as f:
	f.write(enc.strip())
```

Working backwards through enc.py you can see that the string that is written to flag.enc is first generated by sending one character at a time into the function 'c2f()'. An annotated version of enc.py can be found [here](fibinary/enc.py), but in short: c2f() transforms the character into an ASCII value and does a number of checks on it with the 11 first numbers in the fibbonachi sequence. From one character that is passed into c2f, 8 'bits' are returned and written to flag.enc. I say 'bits' cause even though it is written in groups of 8 with 1's and 0's the numbers that return represent values differently than normal binary numbers would.

The next step is to make a python program of our own that can reverse the effect enc.py had on the flag. My "dec.py" program simply used a function that did the exact opposite of the c2f() function. In a great burst of creativity I decided to call it "f2c()":

```python
fib = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

def f2c(c):
	cDec = 0
	for i in range(0,10):
		if c[i] == '1':
			cDec += fib[10-i]
	return chr(cDec)

flagEnc = open('flag.enc','r').read().split()
flag = ''
for c in flagEnc:
	flag += f2c(c)
print(flag)
```
 
Running this program decrypts the flag.enc file and returns the flag:

<details>
<summary>Flag</summary>
<b>corctf{b4s3d_4nd_f1bp!113d}</b>
</details>









